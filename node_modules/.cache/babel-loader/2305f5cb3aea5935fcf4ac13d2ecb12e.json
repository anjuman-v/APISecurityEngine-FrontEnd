{"ast":null,"code":"import { call, put, takeLatest } from \"redux-saga/effects\";\nimport { fetchChatApi1, fetchChatApi2 } from \"../../api\";\nimport { WATCH_CHAT_MEMBERS, WATCH_CHAT_SUCCESS, SEND_MESSAGE_WATCHER, REPLY_MESSAGE_WATCHER, CREATE_CHAT_WATCHER } from \"../../redux/actionTypes\";\nimport { getMembersSuccess, sendMessageToChat, replyMessageToChat, getChats, getChatsSuccess, updateSelectedUser, createChat } from \"../../redux/chap-app/action\";\nfunction* fetchChatMemberAsyn() {\n  const chatData = yield call(fetchChatApi1);\n  yield put(getMembersSuccess(chatData.data));\n}\nfunction* fetchChatAsyn() {\n  const chatData = yield call(fetchChatApi2);\n  const currentUserId = 0;\n  yield put(getChats(chatData.data));\n  const online = true;\n  const chats = chatData.data;\n  const chat = chats.data.filter(x => x.users.includes(currentUserId));\n  const selectedUser = chats.data[0].users.find(x => x !== currentUserId);\n  yield put(getChatsSuccess(chat, selectedUser, online));\n  yield put(updateSelectedUser(selectedUser, online));\n}\nfunction sendMessageAsyn(_ref) {\n  let {\n    currentUserId,\n    selectedUserId,\n    messageInput,\n    chats,\n    online\n  } = _ref;\n  return function* () {\n    let chat = chats.find(x => x.users.includes(currentUserId) && x.users.includes(selectedUserId));\n    const now = new Date();\n    const time = now.getHours() + \":\" + now.getMinutes();\n    const status = online;\n    if (chat) {\n      chat.messages.push({\n        sender: currentUserId,\n        time: time,\n        text: messageInput,\n        status: true\n      });\n      chat.lastMessageTime = time;\n      chat.online = status;\n      let chats_data = chats.filter(x => x.id !== chat.id);\n      chats_data.splice(0, 0, chat);\n      yield put(getChatsSuccess(chats, selectedUserId, online));\n    }\n    yield put(sendMessageToChat(currentUserId, selectedUserId, messageInput, chats, online));\n  }();\n}\nfunction replyByUserAsyn(_ref2) {\n  let {\n    currentUserId,\n    selectedUserId,\n    replyMessage,\n    chats,\n    online\n  } = _ref2;\n  return function* () {\n    let chat = chats.find(x => x.users.includes(currentUserId) && x.users.includes(selectedUserId));\n    const now = new Date();\n    const time = now.getHours() + \":\" + now.getMinutes();\n    const status = online;\n    if (chat) {\n      chat.messages.push({\n        sender: selectedUserId,\n        time: time,\n        text: replyMessage,\n        status: true\n      });\n      chat.lastMessageTime = time;\n      chat.online = status;\n      let chats_data = chats.filter(x => x.id !== chat.id);\n      chats_data.splice(0, 0, chat);\n      yield put(getChatsSuccess(chats_data, selectedUserId, online));\n    }\n    yield put(replyMessageToChat(currentUserId, selectedUserId, replyMessage, chats, online));\n  }();\n}\nfunction createNewChatAsyn(_ref3) {\n  let {\n    currentUserId,\n    selectedUserId,\n    chats\n  } = _ref3;\n  return function* () {\n    yield put(createChat(currentUserId, selectedUserId, chats));\n    let conversation = {\n      id: chats.length + 1,\n      users: [currentUserId, selectedUserId],\n      lastMessageTime: \"-\",\n      messages: []\n    };\n    chats.splice(0, 0, conversation);\n    yield put(getChatsSuccess(chats, selectedUserId));\n  }();\n}\nexport function* WatcherChatApp() {\n  yield takeLatest(WATCH_CHAT_MEMBERS, fetchChatMemberAsyn);\n  yield takeLatest(WATCH_CHAT_SUCCESS, fetchChatAsyn);\n  yield takeLatest(SEND_MESSAGE_WATCHER, sendMessageAsyn);\n  yield takeLatest(REPLY_MESSAGE_WATCHER, replyByUserAsyn);\n  yield takeLatest(CREATE_CHAT_WATCHER, createNewChatAsyn);\n}","map":{"version":3,"names":["call","put","takeLatest","fetchChatApi1","fetchChatApi2","WATCH_CHAT_MEMBERS","WATCH_CHAT_SUCCESS","SEND_MESSAGE_WATCHER","REPLY_MESSAGE_WATCHER","CREATE_CHAT_WATCHER","getMembersSuccess","sendMessageToChat","replyMessageToChat","getChats","getChatsSuccess","updateSelectedUser","createChat","fetchChatMemberAsyn","chatData","data","fetchChatAsyn","currentUserId","online","chats","chat","filter","x","users","includes","selectedUser","find","sendMessageAsyn","_ref","selectedUserId","messageInput","now","Date","time","getHours","getMinutes","status","messages","push","sender","text","lastMessageTime","chats_data","id","splice","replyByUserAsyn","_ref2","replyMessage","createNewChatAsyn","_ref3","conversation","length","WatcherChatApp"],"sources":["/home/anjuman/Desktop/github/APISecurityEngine-FrontEnd/src/redux/chap-app/index.jsx"],"sourcesContent":["import {call,put, takeLatest} from \"redux-saga/effects\";\r\nimport { fetchChatApi1,fetchChatApi2 } from \"../../api\";\r\nimport { WATCH_CHAT_MEMBERS,WATCH_CHAT_SUCCESS,SEND_MESSAGE_WATCHER,REPLY_MESSAGE_WATCHER,CREATE_CHAT_WATCHER } from \"../../redux/actionTypes\";\r\nimport { getMembersSuccess,sendMessageToChat,replyMessageToChat,getChats,getChatsSuccess,updateSelectedUser,createChat} from \"../../redux/chap-app/action\";\r\n\r\n\r\nfunction* fetchChatMemberAsyn() {\r\n    const chatData = yield call(fetchChatApi1);\r\n    yield put(getMembersSuccess(chatData.data));\r\n}\r\n\r\nfunction* fetchChatAsyn() {\r\n\r\n    const chatData = yield call(fetchChatApi2);\r\n    const currentUserId = 0;\r\n    yield put(getChats(chatData.data));\r\n    const online = true;\r\n    const chats = chatData.data;\r\n    const chat = chats.data.filter(x => x.users.includes(currentUserId));\r\n    const selectedUser = chats.data[0].users.find(x => x !== currentUserId);\r\n    yield put(getChatsSuccess(chat,selectedUser,online))\r\n    yield put(updateSelectedUser(selectedUser,online))\r\n}\r\n\r\nfunction* sendMessageAsyn({currentUserId, selectedUserId, messageInput, chats, online}) {\r\n\r\n     let chat = chats.find(x => x.users.includes(currentUserId) && x.users.includes(selectedUserId))\r\n     const now = new Date();\r\n     const time =  now.getHours() + \":\" + now.getMinutes();\r\n     const status=online\r\n     if (chat) {\r\n         chat.messages.push({\r\n             sender: currentUserId,\r\n             time: time,\r\n             text: messageInput,\r\n             status:true\r\n         });\r\n         chat.lastMessageTime = time;\r\n         chat.online = status;\r\n         \r\n         let chats_data = (chats.filter(x => x.id !== chat.id));\r\n         chats_data.splice(0, 0, chat)\r\n         yield put(getChatsSuccess(chats,selectedUserId,online))  \r\n    }\r\n    yield put(sendMessageToChat(currentUserId,selectedUserId,messageInput,chats,online))  \r\n}\r\n\r\nfunction* replyByUserAsyn({currentUserId, selectedUserId, replyMessage, chats, online}) {\r\n  \r\n    let chat = chats.find(x => x.users.includes(currentUserId) && x.users.includes(selectedUserId))\r\n    const now = new Date();\r\n    const time =  now.getHours() + \":\" + now.getMinutes();\r\n    const status= online\r\n    if (chat) {\r\n        chat.messages.push({\r\n            sender: selectedUserId,\r\n            time: time,\r\n            text: replyMessage,\r\n            status:true\r\n        });\r\n        chat.lastMessageTime = time;\r\n        chat.online = status;\r\n        let chats_data = (chats.filter(x => x.id !== chat.id));\r\n        chats_data.splice(0, 0, chat)\r\n\r\n        yield put(getChatsSuccess(chats_data,selectedUserId,online));\r\n    }\r\n    yield put(replyMessageToChat(currentUserId, selectedUserId, replyMessage, chats, online));\r\n}\r\n\r\nfunction* createNewChatAsyn({currentUserId, selectedUserId, chats}) {\r\n\r\n    yield put(createChat(currentUserId, selectedUserId, chats))\r\n    let conversation = {\r\n        id: chats.length + 1,\r\n        users: [currentUserId, selectedUserId],\r\n        lastMessageTime: \"-\",\r\n        messages: []\r\n    };\r\n    chats.splice(0, 0, conversation)\r\n    yield put(getChatsSuccess(chats,selectedUserId))\r\n}\r\n\r\nexport function* WatcherChatApp() {\r\n    yield takeLatest(WATCH_CHAT_MEMBERS,fetchChatMemberAsyn)\r\n    yield takeLatest(WATCH_CHAT_SUCCESS,fetchChatAsyn)\r\n    yield takeLatest(SEND_MESSAGE_WATCHER,sendMessageAsyn)\r\n    yield takeLatest(REPLY_MESSAGE_WATCHER,replyByUserAsyn)\r\n    yield takeLatest(CREATE_CHAT_WATCHER, createNewChatAsyn)\r\n}\r\n\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}